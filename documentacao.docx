core/network/weather_api_client.dart
â†’ Cliente HTTP (poderia opcionalmente ir para data/datasources/ 
se vocÃª quiser separaÃ§Ã£o ainda mais forte)

core/services/weather_service.dart
â†’ Fachada para o cliente HTTP

data/models/weather_model.dart
â†’ Adapta o JSON em entidade

data/repositories/weather_repository_impl.dart
â†’ Implementa a interface de domÃ­nio

domain/entities/weather.dart
â†’ Entidade principal

domain/repositories/weather_repository.dart
â†’ Interface do repositÃ³rio

domain/usecases/get_weather_usecase.dart
â†’ Caso de uso do domÃ­nio

presentation/cubits/weather_cubit.dart
â†’ Estado e lÃ³gica da UI

presentation/screens/weather_screen.dart
â†’ Tela principal

presentation/widgets/weather_card.dart
â†’ Widget reutilizÃ¡vel

main.dart
â†’ InjeÃ§Ã£o manual de dependÃªncias e Bootstrap do app

-----

ğŸ§± VISÃƒO GERAL â€“ Clean Architecture no Flutter

A Clean Architecture propÃµe separar responsabilidades por camadas:
presentation â†’ domain â†’ data â†’ external/core

Ela Ã© Ãºtil para manter o app testÃ¡vel, escalÃ¡vel e de fÃ¡cil manutenÃ§Ã£o.
A ideia Ã© que as camadas internas (domain) nÃ£o dependam das 
externas (presentation, data).

ğŸ“ ESTRUTURA COMPLETA E EXPLICAÃ‡ÃƒO

lib/
Pasta principal do app Flutter.

ğŸ“ presentation/ â†’ Interface com o usuÃ¡rio
Camada que lida com a UI (User Interface) e interaÃ§Ãµes com o usuÃ¡rio. 
Nunca deve conter lÃ³gica de negÃ³cio.

ğŸ“„ screens/
ContÃ©m as telas visuais do app, como WeatherScreen, HomeScreen, etc.
	â€¢	Exemplo: WeatherScreen tem campos de texto, botÃµes e BlocBuilder.

ğŸ“„ cubits/ (ou blocs/)
ContÃ©m classes de gerenciamento de estado, como Cubit, Bloc, etc.
	â€¢	Exemplo: WeatherCubit controla o estado da tela: carregando,
     erro, ou clima carregado.

ğŸ“„ widgets/
Componentes reutilizÃ¡veis de UI, como cards, botÃµes, caixas de entrada.
	â€¢	Exemplo: WeatherCard exibe cidade, temperatura e descriÃ§Ã£o.

ğŸ“ domain/ â†’ Regras de negÃ³cio
Camada central e mais pura. NÃ£o depende de nenhuma outra. 
Aqui estÃ£o as entidades, regras e contratos do app.

ğŸ“„ entities/
Modelos puros que representam o domÃ­nio do negÃ³cio.
	â€¢	Exemplo: Weather com cityName, temperature, description.

ğŸ“„ repositories/
Interfaces (contratos) que descrevem o que a aplicaÃ§Ã£o precisa de dados, 
sem se importar de onde vÃªm (API, banco, cacheâ€¦).
	â€¢	Exemplo: WeatherRepository define Future<Weather> getWeather(String cityName).

ğŸ“„ usecases/
Representam aÃ§Ãµes especÃ­ficas da regra de negÃ³cio.
	â€¢	Exemplo: GetWeatherUseCase usa o repositÃ³rio para buscar o clima de uma cidade.

ğŸ“ data/ â†’ ImplementaÃ§Ãµes concretas
Camada que implementa os contratos do domÃ­nio. 
Aqui lidamos com API, bancos, arquivos etc.

ğŸ“„ models/
Classes que adaptam dados brutos (JSON) em entidades do domÃ­nio.
	â€¢	Exemplo: WeatherModel.fromJson converte o JSON em uma instÃ¢ncia
     de Weather.

ğŸ“„ repositories/
ImplementaÃ§Ãµes das interfaces do domÃ­nio.
	â€¢	Exemplo: WeatherRepositoryImpl implementa WeatherRepository e usa um service para buscar dados da API.

ğŸ“„ datasources/ (opcional)
Se quiser separar ainda mais, vocÃª pode colocar aqui classes 
como WeatherApiClient, que interagem diretamente com o 
back-end ou banco local.

ğŸ“ core/ â†’ CÃ³digo compartilhado e utilitÃ¡rios
ContÃ©m classes compartilhadas e utilitÃ¡rias, como chamadas HTTP, 
injeÃ§Ã£o de dependÃªncia, serviÃ§os, constantes, temas etc.

ğŸ“„ network/
Classes responsÃ¡veis por se comunicar com serviÃ§os externos.
	â€¢	Exemplo: WeatherApiClient chama a OpenWeather API e retorna JSON.

ğŸ“„ services/
Facades ou wrappers que simplificam o uso de network/.
	â€¢	Exemplo: WeatherService abstrai WeatherApiClient e prepara os dados para os repositÃ³rios.

ğŸ“„ utils/
FunÃ§Ãµes, validadores, extensÃµes e helpers reutilizÃ¡veis.

ğŸ“„ themes/
ConfiguraÃ§Ãµes de tema para o app: cores, fontes, estilos etc.


ğŸ“„ main.dart â†’ Bootstrap do app

ResponsÃ¡vel por:
	â€¢	Criar instÃ¢ncias (injeÃ§Ã£o manual ou via get_it)
	â€¢	Iniciar o app
	â€¢	Configurar o BlocProvider (ou Riverpod, etc)

ğŸ”„ Fluxo de execuÃ§Ã£o (exemplo real)

UsuÃ¡rio digita cidade na UI
 â†“
WeatherCubit chama useCase("Franca")
 â†“
UseCase chama WeatherRepository.getWeather()
 â†“
WeatherRepositoryImpl chama WeatherService.getWeatherData()
 â†“
WeatherService chama WeatherApiClient.fetchWeather()
 â†“
API responde com JSON
 â†“
WeatherModel.fromJson converte o JSON
 â†“
WeatherRepositoryImpl retorna a entidade Weather
 â†“
UseCase retorna o Weather para o Cubit
 â†“
Cubit emite novo estado com clima
 â†“
UI (WeatherScreen) exibe WeatherCard